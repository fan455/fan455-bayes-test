This repository contains the Rust and Python codes for the author's working paper "Autocorrelated Errors in Panel Linear Regression A New Objective Bayesian Perspective". It includes an array library `fan455_arrf64` and a Rust implementation of [Stan No-U-Turn-Sampler](https://github.com/stan-dev/stan), which are written as flexible as possible to be used for other numerical and statistical works. 

The libraries `fan455_arrf64` and `fan455_arrf64_macro` uses Rust's `Vec` struct to allocate vector/matrix memory on the head, supporting any primitive types for array elements with a focus on f64. This array library targets high performance on CPUs and super simple, flexible, and customizable functionalities. You can easily add or modify this library, mainly focusing on `src/fan455_arrf64/arrf64_basic.rs`. This file uses Rust's traits to provide vector/matrix operations (indexing, assigning values, numeric computation, linear algebra, ...) for my written structs like `Arr1`, `Arr2`, `SArr2`, `SArr2`, and also Rust's `Vec`, `Array`. `Arr1` and `Arr2` are simply super-light wrappers of `Vec`, and `SArr2`, `SArr2` are simply super-light wrappers of `Array`. What's more, you can perform most operations on a subvector of a matrix or a column of a matrix in a way that's very similar to full vectors/matrices, without actually copying the large blocks of data. For linear algebra, this library provides light wappers of external BLAS/LAPACK libraries like Intel MKL, and a more user-friendly way to call BLAS/LAPACK through Rust's `proc_macro` supporting default values and arbitrary pass orders for arguments like trans, uplo, side. Even with so flexible features, most functions/methods here can be written only once with the support of traits which makes them easier to maintain.

The library `fan455_bayes` contains a simplified Rust implementation of Stan NUTS (dense_e_metric only), mainly for the purpose of supporting analytic gradients. In many cases, available analytic gradients can bring faster computation speeds for NUTS compared to numeric or automatic differentiation approaches. To use NUTS to sample from your own Bayes model, you just need to implement the `BayesModel` trait defined in `fan455_bayes/src/bayes_model_base.rs`. I made some more modifications to the original Stan NUTS C++ code that may gain faster speed, including reducing unnecessary memory allocations/deallocations, using MKL which is faster than Eigen, calling BLAS routines specific to symmetric or triangular matrices, and eliminating an unnecessary step that calls the model's gradient function.

The libraries `fan455_util` and `fan455_util_macro` provide functionalities including: parsing command line arguments (different from the [clap](https://github.com/clap-rs/clap) crate, variables are parsed straight into scope without the need to define a struct); reading and writing numpy's `.npy` files; zipping more than 2 iterators; writing CSV files.

Test examples are in the `examples` folder, which users on 64-bit Windows can directly run. Guidance to run the examples are provided [here](./examples/README.md). If you are not on 64-bit Windows, you just need to set up a Rust environment to compile the codes on your own.

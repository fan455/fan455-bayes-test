# fan455-bayes-test

This repository contains the Rust and Python codes for the author's working paper *Autocorrelated Errors in Panel Linear Regression A New Objective Bayesian Perspective*. It includes an array library `fan455_arrf64` and a Rust implementation of [Stan No-U-Turn-Sampler](https://github.com/stan-dev/stan), which are written as flexible as possible to be used for other numerical and statistical works. 

The libraries `fan455_arrf64` and `fan455_arrf64_macro` uses Rust's `Vec` and `array` struct to allocate vector/matrix memory on the heap or on the stack, supporting any primitive types for array elements with a focus on f64. This array library is towards high performance on CPUs and super simple, flexible, and customizable functionalities. You can easily add or modify this library, mainly focusing on [arrf64_basic.rs](src/fan455_arrf64/src/arrf64_basic.rs). This file uses Rust's traits to provide vector/matrix operations (index, slice, reshape, assign values, numeric computations, linear algebra, ...) for my written structs like `Arr1`, `Arr2`, `SArr2`, `SArr2`, and also Rust's `Vec`, `array`. `Arr1` and `Arr2` are light wrappers of `Vec`, and `SArr2`, `SArr2` are light wrappers of `array`. Please notice that the `Arr2` and `SArr2` structs, which provide matrix functionalities, are indexed in column-major (Fortran order) but the `dim0` and 'dim1' fields of them are in row-major (C order). What's more, you can treat a (m, n) matrix as a (m*n, 1) vector without changing memory allocations, you can also perform most operations on a subvector of a vector or column(s) of a matrix in a way that's very similar to full vectors/matrices, without actually cloning large blocks of data thanks to the `VecView` and `MatView` types. For linear algebra, this library provides light wappers of external BLAS/LAPACK libraries like Intel MKL, and a more user-friendly way to call BLAS/LAPACK through Rust's `proc_macro` supporting default values and arbitrary pass orders for arguments like trans, uplo, side. Even with so flexible features, most functions/methods here can be written only once with the support of traits which makes them easier to maintain.

The library `fan455_bayes` contains a simplified Rust implementation of Stan NUTS (dense_e_metric only), mainly for the purpose of supporting analytic gradients. In many cases, available analytic gradients can bring faster computation speeds for NUTS compared to numeric or automatic differentiation approaches. To use NUTS to sample from your own Bayes model, you just need to implement the `BayesModel` trait defined in [bayes_model_base.rs](src/fan455_bayes/src/bayes_model_base.rs). I made some more modifications to the original Stan NUTS C++ code that may gain faster speed, including reducing unnecessary memory allocations/deallocations, using MKL which is faster than Eigen, calling BLAS routines specific to symmetric or triangular matrices, and eliminating an unnecessary step that calls the model's gradient function.

The libraries `fan455_util` and `fan455_util_macro` provide functionalities including: parsing command line arguments (different from the [clap](https://github.com/clap-rs/clap) crate, variables are parsed straight into scope without the need to define a struct); reading and writing numpy's `.npy` files; zipping more than 2 iterators; writing CSV files.

The only parts in the Rust codes of this repository that use `unsafe` are: calling BLAS/LAPACK routines; reading and writing `.npy` files in transmuted ways (reading `.npy` in safe ways instead may be slower due to the overheads of converting each `u8` array in a block of memory into target types like f64). Other parts are guaranteed to be safe-only.

Test examples are in the `examples` folder, which users on 64-bit Windows can directly run. Guidance to run the examples are provided [here](examples/README.md). If you are not on 64-bit Windows or want to compile more native binaries, you just need to set up a Rust environment to compile the codes on your own.
